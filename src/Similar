Construct binary tree preorder/inorder traversal
105, 106

Binary tree, Binary search tree, Binary search
108, 109

binary search
33. Search in Rotated Sorted Array
81. Search in Rotated Sorted Array II
153. Find Minimum in Rotated Sorted Array
34. Find First and Last Position of Element in Sorted Array
278. First Bad Version
35. Search Insert Position
374. Guess Number Higher or Lower
50. Pow(x, n) (Math)

find missing number/duplicates from array
41. First Missing Positive
136. Single Number (bit manipulation)
268. Missing Number
287. Find the Duplicate Number
442. Find All Duplicates in an Array
448. Find All Numbers Disappeared in an Array

Dynamic programing
53. Maximum Subarray
152. Maximum Product Subarray
    string conversion
        97. Interleaving String
        583. Delete Operation for Two Strings
        72. Edit Distance
        712. Minimum ASCII Delete Sum for Two Strings

LIS
300. Longest Increasing Subsequence
673. Number of Longest Increasing Subsequence
354. Russian Doll Envelopes
646. Maximum Length of Pair Chain





排列组合/backtrack/DFS
22. Generate Parentheses, consider number of open and close parentheses
17. Letter Combination of a Phone Number
39. Combination Sum
40. Combination Sum II
216. Combination Sum III
78. Subsets
90. Subsets II
46. Permutations
47. Permutations II
131. Palindrome Partitioning
*267. Palindrome Permutation II
113. Path Sum II
*79. Word Search
[H, x]37. Sudoku Solver
[H]51. N-Queens

Linkedlist

19. Remove Nth Node From End of List, two pointers(slow and fast) which maintain a gap of n, both move forward until fast reaches end, slow.next = slow.next.next
83. Remove Duplicates from Sorted List - only delete duplicates
82. Remove Duplicates from Sorted List II - delete all numbers and their duplicates
237. Delete Node in a Linked List - head not given, node given is the node that needs to be delete, change its value to next's and skip next
203. Remove Linked List Elements
*206. Reverse Linked List
92. Reverse Linked List II
234. Palindrome Linked List - use slow and fast pointer to find mid element(be careful about odd or even number of nodes), reverse right half and compare values
141. Linked List Cycle
142. Linked List Cycle II
24. Swap Node in Pairs - awesome diagram: https://leetcode.com/problems/swap-nodes-in-pairs/discuss/11046/My-simple-JAVA-solution-for-share/186959
2. Add Two Numbers
160. Intersection of Two Linked Lists - get length of both lists, move/align longer list first and move both lists at the same time to reach the intersection
21. Merge Two Sorted Lists
*148. Sort List - merge sort
*147. Insertion Sort List
61. Rotate List - get the length of the input linked list which is n, move to n-k%n and rotate
86. Partition List - maintain two lists, one holds nodes < x, one holds nodes >= x and connect them, O(n)
[!]23. Merge k Sorted Lists
328. Odd Even Linked List - space complexity requirement is O(1), in place

String
28. Implement strStr()
14. Longest Common Prefix
58. Length of Last Word
151. Reverse Words in a String - split using s.trim().split("\\s+") and reverse words
186. Reverse Words in a String II - reverse the whole string(input), and reverse each word again(guaranteed to have one single space between words)
205. Isomorphic Strings - use hashmap to save char mapping and check along the way that if mapping of char to another char is one to one only
293. Flip Game - important: str.substring(str.length()) == ""
*242. Valid Anagram - use int[26] or hashmap
*49. Group Anagrams - iterate through each string -> sort it -> maintain a hashmap of string : list
*249. Group Shifted Strings - two strings are considered shifted if the difference between each char is the same, for example, acd -> 2 1, dfg -> 2 1, mop -> 2 1
iterate through each string and calculate such difference, use a hashmap to keep track of all shifted strings that have the same difference
179. Largest Number - sort the array using a comparator that compares s1 concat s2 with s2 concat s1
161. One Edit Distance
38. Count and Say
*168. Excel Sheet Column Title - while n>0 -> n-- -> n%26 -> n/26
171. Excel Sheet Column Number
12. Integer to Roman
13. Roman to Integer
[H, !]273. Integer to English Words
*246. Strobogrammatic Number
*247. Strobogrammatic Number II
[H, !]68. Text Justification
[H, !]65. Valid Number
*157. Read N Characters Given Read4
158. Read N Characters Given Read4 II - Call multiple times
[H, !]214. Shortest Palindrome - KMP
[low priority]165. Compare Version Numbers - split("\\.");

Sliding Window - String
[H, *]76. Minimum Window Substring
[H, !]30. Substring with Concatenation of All Words
*3. Longest Substring Without Repeating Characters
*340. Longest Substring with At Most K Distinct Characters
*159. Longest Substring with At Most Two Distinct Characters

Palindrome - String
*125. Valid Palindrome - use of built-in method of Character.isLetterOrDigit(), compare characters using two pointers head and tail, skip if non alphanumeric
*266. Palindrome Permutation - use hashset or hashmap - only one character can appear odd number of times, all the other characters must appear even number of times

Parentheses - String
*20. Valid Parentheses - use a stack -> push corresponding closing brackets if opening brackets are encountered -> if closing brackets are encountered, pop stack and compare -> stack should not be empty at the end
[H, *]32. Longest Valid Parentheses - use a stack, push the index of (, pop the stack when ) is encountered

DP - 2D array
*5. Longest Palindromic Substring - draw the dp table and visualize, the start/end indexes can be set using many different ways
[H, !]132. Palindrome Partitioning II

Math
*9. Palindrome Number
*7. Reverse Integer - check overflow: if ((newResult - tail) / 10 != result)
8. String to Integer (atoi) - another way to check overflow: if(Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
66. Plus One - from last element to first element of the array, if it is less than 9, add 1 to it and return, otherwise set it to 0 and continue, after the iteration if first element becomes 0(for example 999 -> 000), create a new array of n+ 1 sizeand set 0 index to be 1
[low priority]258. Add Digits
67. Add Binary
[x]43. Multiply Strings
[x]29. Divide Two Integers
231. Power of Two - using iterative solution is trivial, use bitwise solution: (x & (-x)) == x
[low priority]326. Power of Three
[low priority]342. Power of Four
191. Number of 1 Bits - for each bit, AND with 1 and the result is 1 if the bit is 1
292. Nim Game
*202. Happy Number
263. Ugly Number
[low priority]172. Factorial Trailing Zeroes

Binary Search
167. Two Sum II - Input Array Is Sorted

Uncategorized
31. Next Permutation, from right to left find first element that breaks ascending order, swap with next largest element to its right and reverse the rest
*1. Two Sum
170. Two Sum III - Data structure design
*15. 3Sum
*16. 3Sum Closest
259. 3Sum Smaller
[x]18. 4Sum
[x]560. Subarray Sum Equals K

Array
27. Remove Element
26. Remove Duplicates from Sorted Array
80. Remove Duplicates from Sorted Array II
277. Find the Celebrity
189. Rotate Array - reverse whole array once, reverse 0-k once, and reverse k - end once
[H]41. First Missing Positive - mark zero, negative numbers and numbers that are greater than the total length of the input array as Integer_MAX or length + 1, iterate through the array, make nums[Math.abs(nums[i])] as negative
*134. Gas Station - first pass add up all gas[i] - cost[i] to see if there exists a solution, second pass(solution guaranteed) add up gas[i] - cost[i] until total becomes less than zero, set answer to i + 1.
118. Pascal's Triangle
119. Pascal's Triangle II
169. Majority Element - moore voting algorithm, maintain a candidate variable and a count variable (only works when input has a majority element that appears > n/2 times and this problem assumes it always exists)
229. Majority Element II - maintain four variables, two candidates and two count, don't forget to check candidates are indeed majority element at the end as they might not exist in this problem
274. H-Index - sort the array in descending order and visual the histogram y axis as the number of citation and x axis as the citation index, the length of the largest square will be the answer here. Find the largest i that nums[i] > i, and i + 1 is the answer.
243. Shortest Word Distance
244. Shortest Word Distance II - create a hashmap with the key being each string in the input and the value will be a (sorted)list of its indexes in the input. Given two words, calculate min distance according to their indexes lists.
245. Shortest Word Distance III - similar to Shortest Word Distance II, if two indexes are the same just continue
217. Contains Duplicate
219. Contains Duplicate II
[low priority]220. Contains Duplicate III
*121. Best Time to Buy and Sell Stock
*122. Best Time to Buy and Sell Stock II
*11. Container With Most Water
334. Increasing Triplet Subsequence - maintain two variables min1 and min2(min1 < min2)
*128. Longest Consecutive Sequence - add all elements to a set, iterate through the input array and for each element see if the set contains the consecutive elements to its left and also to its right, do not forget to remove them from the set if found.
[H, low priority]164. Maximum Gap
287. Find the Duplicate Number - apply the Floyd's cycle detection algorithm
[H]135. Candy - create two arrays fill all elements to be 1, scan input array twice, from left to right once and from right to left once, if current element's rating is higher than its neighbor, add 1, at the end iterate through both array and take the max of both elements from left and right array
*57. Insert Interval - two while loops - newInterval.start > element.end (find intervals to the left of the new interval), newInterval.end >= element.start(merge overlapping intervals), also add the rest of the intervals(intervals to the right of the new interval).
*56. Merge Intervals - sort the input array by interval's start time
*252. Meeting Rooms - sort the input array by interval's start time
*253. Meeting Rooms II - sort the input array by start time, use priority queue(min heap), add first element's end in the priority queue first, iterate through the end, if current element's start >= peek() which means no conflict, poll from the queue, next always add current element's end to the queue, the result will be the final size of the queue.
[H, *, needs review]239. Sliding Window Maximum - the idea of a monotonically decreasing queue which can be implemented using a deque
325. Maximum Size Subarray Sum Equals k - iterate through the input array and save prefix sum as key and current index in a hashmap, if (prefix sum - k)  exists in the hashmap that means there exists a subarray with sum k.
*238. Product of Array Except Self
[low priority]228. Summary Ranges
[low priority]163. Missing Ranges
*88. Merge Sorted Array - merge from the end of both array so that there is no need to create a new array
*75. Sort Colors - maintain a left index that to the left of this index it will be all zeros, maintain a right index that to the right of this index it will be all 2s, iterate through the input array and if the current element is 0, swap with nums[left], left++, index++, if the current element is 1, continue the loop, if the current element is 2, swap with nums[right], right--, but do not increase the index here.
*283. Move Zeroes - iterate through the input array, if the element is not zero, move it to the front, fill the rest of the array with 0s after the iteration ends.

DP - Array
[H]123. Best Time to Buy and Sell Stock III
[H, low priority]188. Best Time to Buy and Sell Stock IV
[H, *]42. Trapping Rain Water
*53. Maximum Subarray
*152. Maximum Product Subarray

Greedy - Array
55. Jump Game - iterate through the input array and maintain a maxReach variable (i + nums[i])
45. Jump Game II - implicit BFS in one dimensional array, maintain a jump(level) variable, a curMax and nextMax variable, assign nextMax to curMax when a new level starts
[H, low priority, X]321. Create Maximum Number
[H, low priority, X]327. Count of Range Sum

Matrix - 2D Array
*48. Rotate Image - reverse matrix horizontally and transpose(swap) along the diagonal
*54. Spiral Matrix - important while condition: result.size() < rows * columns, maintain four variables, left, right, up and down
59. Spiral Matrix II
73. Set Matrix Zeroes - check if first row and column has zero, start from second row & column if current element is 0 then mark first row and column to be 0, iterate through first column and row once, if it is 0 then mark whole column/row of the matrix to be 0, if first column and row originally have 0 then mark whole row/column to be 0 too.
[low priority, x]311. Sparse Matrix Multiplication
240. Search a 2D Matrix II - start from bottom left element(or upper right), if target is smaller than the element, search up, if target is larger than the element, search right
[low priority, H, x]296. Best Meeting Point
*36. Valid Sudoku - create 3 list/array of 9 hashsets each for the matrix's 9 rows, 9 column and 9 cubes(3*3 cube), iterate through whole matrix add the element to the corresponding hashset if the element is not empty, the index of the cube in the hashset array/list is idx = (r / 3) * 3 + c / 3

Matrix - DFS/BFS
*200. Number of Islands
*286. Walls and Gates - BFS level order traversal, start from all the gates
130. Surrounded Regions - DFS and mark all 0 on the border of the matrix to be 1, iterate through the matrix, mark the remaining 0 to be X and 1 back to 0.

General DFS/BFS
[H, *]127. Word Ladder -

Matrix - backtracking
[H, *]51. N-Queens -
[H, *]52. N-Queens II -

Sliding Window/Two Pointers - Array
*209. Minimum Size Subarray Sum

Binary Search
275. H-Index II
[H, *]4. Median of Two Sorted Arrays
*278. First Bad Version
*35. Search Insert Position
*74. Search a 2D Matrix - binary search in a matrix, mid element position in the matrix: row = index / n and col = index % n

Binary Tree
*144. Binary Tree Preorder Traversal
*94. Binary Tree Inorder Traversal - look for leftmost node, add the nodes along the way to stack, pop the stack and add the node's value to list, continue the operation for the right node(if exists)
145. Binary Tree Postorder Traversal
*102. Binary Tree Level Order Traversal
*107. Binary Tree Level Order Traversal II
*103. Binary Tree Zigzag Level Order Traversal
*100. Same Tree
*101. Symmetric Tree
*226. Invert Binary Tree
*257. Binary Tree Paths
*112. Path Sum
*113. Path Sum II
*129. Sum Root to Leaf Numbers
298. Binary Tree Longest Consecutive Sequence
*111. Minimum Depth of Binary Tree
*104. Maximum Depth of Binary Tree
[x]110. Balanced Binary Tree
[H,x]124. Binary Tree Maximum Path Sum
[low priorty]250. Count Univalue Subtrees

Stack/Queue/Priority Queue
*155. Min Stack - use two stacks
716. Max Stack
232. Implement Queue using Stacks
[low priority]225. Implement Stack using Queues
150. Evaluate Reverse Polish Notation
[*]71. Simplify Path - split with "/", iterate through the array, pop stack if it is ".."(if stack is not empty), push if it is not "." or empty string, at the end pop the stack and append with / each time to form the result
[*]227. Basic Calculator II
[H, *]224. Basic Calculator
[H, x]84. Largest Rectangle in Histogram
[*, needs review]215. Kth Largest Element in an Array - 1. use a priority queue and keep the size to be k, poll whenever size > k  2. quickselect(needs review)

X - do not understand the solution or problem is skipped
* - important
H - hard
low priority - do not frequently show up in the leetcode companies section
needs review - partially understand the solution/needs more understanding